<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use ReflectionEnum;
use ReflectionEnumBackedCase;

class ExportEnumsToJs extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'enums:export-js';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Export all PHP enums from app/Enums to JavaScript files in resources/js/Enums';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        $enumsPath = app_path('Enums');
        $jsPath = resource_path('js/Enums');

        // Create js/Enums directory if it doesn't exist
        if (!is_dir($jsPath)) {
            mkdir($jsPath, 0755, true);
            $this->info("Created directory: {$jsPath}");
        }

        // Check if Enums directory exists
        if (!is_dir($enumsPath)) {
            $this->error("Directory {$enumsPath} does not exist!");
            return Command::FAILURE;
        }

        // Get all PHP files in Enums directory
        $enumFiles = glob($enumsPath . '/*.php');

        if (empty($enumFiles)) {
            $this->warn("No enum files found in {$enumsPath}");
            return Command::SUCCESS;
        }

        $exportedCount = 0;

        foreach ($enumFiles as $enumFile) {
            $className = $this->getClassNameFromFile($enumFile);

            if (!$className) {
                $this->warn("Could not determine class name from: " . basename($enumFile));
                continue;
            }

            $fullClassName = "App\\Enums\\{$className}";

            // Check if class exists and is an enum
            if (!class_exists($fullClassName) || !enum_exists($fullClassName)) {
                $this->warn("{$fullClassName} is not a valid enum, skipping...");
                continue;
            }

            try {
                $reflection = new ReflectionEnum($fullClassName);
                $jsContent = $this->generateJsContent($reflection, $className);

                $jsFileName = $jsPath . '/' . $className . '.js';
                file_put_contents($jsFileName, $jsContent);

                $this->info("Exported: {$className} -> " . basename($jsFileName));
                $exportedCount++;
            } catch (\Exception $e) {
                $this->error("Error processing {$className}: " . $e->getMessage());
            }
        }

        $this->info("\nSuccessfully exported {$exportedCount} enum(s) to {$jsPath}");
        return Command::SUCCESS;
    }

    /**
     * Extract class name from PHP file
     */
    private function getClassNameFromFile(string $filePath): ?string
    {
        $content = file_get_contents($filePath);

        // Try to match enum declaration
        if (preg_match('/enum\s+(\w+)/', $content, $matches)) {
            return $matches[1];
        }

        return null;
    }

    /**
     * Generate JavaScript content from enum reflection
     */
    private function generateJsContent(ReflectionEnum $reflection, string $className): string
    {
        $cases = $reflection->getCases();
        $isBacked = $reflection->isBacked();
        $backedType = $isBacked ? $reflection->getBackingType()->getName() : null;

        $jsLines = [];
        $jsLines[] = "// Auto-generated from PHP enum: App\\Enums\\{$className}";
        $jsLines[] = "// Do not edit this file manually";
        $jsLines[] = "";

        // Export as object
        $objectLines = [];
        $constantLines = [];

        foreach ($cases as $case) {
            $caseName = $case->getName();

            if ($isBacked && $case instanceof ReflectionEnumBackedCase) {
                $value = $case->getBackingValue();

                // Format value based on type
                if ($backedType === 'string') {
                    $formattedValue = "'{$value}'";
                } elseif ($backedType === 'int') {
                    $formattedValue = $value;
                } else {
                    $formattedValue = json_encode($value);
                }

                $objectLines[] = "    {$caseName}: {$formattedValue},";
                $constantLines[] = "export const {$caseName} = {$formattedValue};";
            } else {
                // Pure enum (not backed)
                $objectLines[] = "    {$caseName}: '{$caseName}',";
                $constantLines[] = "export const {$caseName} = '{$caseName}';";
            }
        }

        // Export object
        $jsLines[] = "export const {$className} = {";
        $jsLines = array_merge($jsLines, $objectLines);
        $jsLines[] = "};";
        $jsLines[] = "";

        // Export individual constants
        $jsLines = array_merge($jsLines, $constantLines);
        $jsLines[] = "";

        // Export default (the object)
        $jsLines[] = "export default {$className};";

        return implode("\n", $jsLines);
    }
}

